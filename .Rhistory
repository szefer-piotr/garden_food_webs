# for(grd in names(gardnets)){
#   print(grd)
#   print(dim(gardnets[[grd]]))
# }
#
# vaznull(10, gardnets[["w1g2p4"]])
# One line netwrok can also be randomized
randomizations <- 1
genvuldf <- data.frame()
# gname <- "w1g2p3"
# gname <- names(gardnets)[[2]]
dddf <- list()
# *1.0 Run the loop ----
for(gname in names(gardnets)){
print(gname)
# Create a list of randomized networks
MAT <- gardnets[[gname]]
# Randomization!
RandMAT <- vaznull(randomizations, MAT)
randomAverageData <- data.frame()
# Calculate indices for randomized networks
for(net in 1:length(RandMAT)){
rMAT <- RandMAT[[net]]
# rownames(rMAT) <- rownames(MAT)
colnames(rMAT) <- colnames(MAT)
rMAT_noip <- rMAT[,-grep(c("mant|aran"),
colnames(rMAT))]
tt <- tryCatch(networklevel(rMAT,
index = "vulnerability"),
error=function(e) e,
warning=function(w) w)
ifelse(is(tt,"warning"),
next,
print(net))
if(is.null(gardnets[[gname]])){
next
}
dddf[[gname]] <- rowSums(rMAT_noip>0)
nlres <- networklevel(rMAT_noip, index = "vulnerability")
pdi <- mean(PDI(rMAT_noip, normalise = T, log=T))
con <-  networklevel(rMAT_noip, index = "connectance")
# Randomized
mod1 = DIRT_LPA_wb_plus(rMAT_noip)
MODinformation = GetModularInformation(rMAT_noip,mod1)
mod = MODinformation$normalised_modularity
ispp = ncol(rMAT[, substr(colnames(rMAT),
1,
4) %in% c("aran",
"mant")])
isph = ncol(rMAT) - ispp
ntd = networklevel(rMAT_noip, index = "nestedness")
asym = networklevel(rMAT_noip, index = "web asymmetry")
rsubgvdf <- data.frame(plot = gname,
gen = nlres[1],
vul = nlres[2],
pdi = pdi,
con = con,
mod = mod,
isph=isph,
ispp = ispp,
nestedness = ntd,
asym = asym)
randomAverageData <- rbind(randomAverageData, rsubgvdf)
}
rAD <- apply(randomAverageData[, -1],
2,
mean)
# Remove ips
MAT_noip <- MAT[,-grep(c("mant|aran"),colnames(MAT))]
# Some networks are too small, print their names, count them!
tt <- tryCatch(networklevel(MAT, index = "vulnerability"),error=function(e) e, warning=function(w) w)
ifelse(is(tt,"warning"),next,print("OK"))
if(is.null(gardnets[[gname]])){
next
}
nlres <- networklevel(MAT_noip, index = "vulnerability")
pdi <- mean(PDI(MAT_noip, normalise = T, log=T))
con <-  networklevel(MAT_noip, index = "connectance")
mod1 = DIRT_LPA_wb_plus(MAT_noip)
MODinformation = GetModularInformation(MAT_noip,mod1)
mod = MODinformation$normalised_modularity
# https://royalsocietypublishing.org/doi/full/10.1098/rsos.140536
# 1 when all links exists between modules
ispp = ncol(MAT[, substr(colnames(MAT),1,4) %in% c("aran", "mant")])
isph = ncol(MAT) - ispp
ntd = networklevel(MAT_noip, index = "nestedness")
asym = networklevel(MAT_noip, index = "web asymmetry")
subgvdf <- data.frame(plot = gname,
gen = nlres[1],
vul = nlres[2],
pdi = pdi,
con = con,
mod = mod,
isph=isph,
ispp = ispp,
nestedness = ntd,
asym = asym, # here
rgen = rAD[1],
rvul = rAD[2],
rpdi = rAD[3],
rcon = rAD[4],
rmod = rAD[5],
risph= rAD[6],
rispp =rAD[7],
rnestedness = rAD[8],
rasym = rAD[9])
genvuldf <- rbind(genvuldf, subgvdf)
}
#***************************************************
rownames(treats) <- treats$codes
genvuldf$trt <- treats[as.character(genvuldf$plot),
]$treat
genvuldf$block <- substr(genvuldf$plot, 3,4)
# Get relative indices... not needed anymore
# Nestedness Modularity
genvuldf$rnest_val <- with(genvuldf, {
(nestedness - rnestedness)/rnestedness
})
# genvuldf$rpdi_val <- with(genvuldf, {
#   (pdi - rpdi)/rpdi
# })
# genvuldf$rpdi_val <- with(genvuldf, {
#   (pdi - rpdi)/rpdi
# })
# Modularity and randomized modularity
# genvuldf$mod
# genvuldf$rmod
# *1.1 Network size and PDI index ----
# nsizedf <- data.frame()
# for (plt in genvuldf$plot){
#   subnet <- gardnets[[plt]]
#   subnet <- subnet[,-grep(c("mant|aran"),
#                           colnames(subnet))]
#   nsizerow <- data.frame(plants = dim(subnet)[1],
#                          invert = dim(subnet)[2],
#                          pdi = genvuldf[genvuldf$plot == plt, ]$pdi,
#                          treatment = treats[treats$codes == plt, ]$treat )
#   nsizedf <- rbind(nsizedf, nsizerow)
# }
#
# ggplot(nsizedf, aes(x = pdi, y = plants, color = treatment))+
#   geom_point() +
#   geom_smooth(method="lm")
#
# lm1 <- lm(pdi~plants*treatment, data = nsizedf)
# summary(lm1)
# lm1 <- lm(pdi~plants, data = nsizedf[nsizedf$treatment == "INSECTICIDE",])
# summary(lm1)
# PDI doesnt seem to be dependent on the network size
# *1.2 Setup for plots ----
# But generality would also change if the number of plant at the plot is smaller!
gen <- genvuldf[,c("plot","gen","trt","block")]
vul <- genvuldf[,c("plot","vul","trt","block")]
pdi <- genvuldf[,c("plot","pdi","trt","block")]
con <- genvuldf[,c("plot","con","trt","block")]
mod <- genvuldf[,c("plot","mod","trt","block")]
isph <- genvuldf[,c("plot","isph","trt","block")]
ispp <- genvuldf[,c("plot","ispp","trt","block")]
ntd <- genvuldf[,c("plot","nestedness","trt","block")]
# Change names
colnames(gen) <- colnames(vul) <- colnames(pdi) <- colnames(con) <- colnames(mod) <- colnames(isph) <- colnames(ispp) <- colnames(ntd) <- c("plot","ind","trt","block")
plotdat <- rbind(gen, vul, pdi, con, mod, isph, ispp, ntd)
plotdat$type <- rep(c("Generality", "Vulnerability", "Specialization PDI", "Connectance",
"Modularity", "Herbivore Species",
"IP Species", "Nestedness"),
each=length(as.character(genvuldf$plot)))
# pdf("manuscript/figs/descriptors.pdf", 7, 7)
# clip ds to only C vs P comparison
# *1.3 Facet plot all descriptors ----
# p <- ggplot(plotdat, aes(x = trt, y = ind))
# p + stat_summary(fun.data=mean_cl_boot,
#                                 geom="pointrange", width=0.1,
#                  color = "red", lwd=1) +
#   stat_summary(fun.y=mean, geom="point", color="red", cex = 2) +
#   geom_jitter(width = 0.1, col = rgb(128,128,128, alpha = 100, maxColorValue = 255)) +
#   theme_bw() +
#   theme(axis.text.x=element_text(angle=90, size=5, hjust=0.5))+
#   facet_wrap(~type, scales="free")
# dev.off()
# Add plant species richness to the plotdat
sr <- as.data.frame(tapply(plants$SPEC, plants$CODE, function(x){length(unique(x))}))
plotdat$sr <- sr[plotdat$plot,]
# 2. Test for differences ----
# 2.1 Filter data ----
desStatMod <- function(data, descriptor){
# Creates a subset from data for a given descriptor
print(descriptor)
subdat <- data[data$type == descriptor, ]
sublm <- lmer(ind ~ trt + (1|block), data=subdat)
print(summary(sublm))
return(subdat)
}
# Create a logit function
logit <- function(x){log(x/(1-x))}
# Filter only plots that I want to plot
clippedpd <- plotdat[plotdat$trt %in% treats_to_plot,]
clippedpd$trt <- as.character(clippedpd$trt)
# Assign colors for significant and non-significant differences
sigcol <- rgb(255,0,0,150,maxColorValue = 255)
nsigcol <- rgb(211,211,211,150,maxColorValue = 255)
# For now its all the same:
clippedpd$colors <- nsigcol
# 2.2 Connectance - significant somewhat----
condat <- desStatMod(clippedpd, "Connectance")
# var.test(ind~trt, data = condat)
# bartlett.test(ind~trt, data = condat)
car::leveneTest(ind~trt, data = condat)
# Relevel
condat$trt <- factor(condat$trt,
levels = c("CONTROL",
"PREDATOR",
"WEEVIL125",
"WEEVIL25",
"INSECTICIDE"))
# conlmer1 <- lmer(logit(ind)~trt+(1|block), condat)
# conlme1 <- nlme::lme(logit(ind)~trt, random = ~1|block, condat)
# summary(conlme1)
# Use beta distribution
brrand <- glmmTMB(ind ~ trt + (1|block), data = condat,
family= beta_family(link = "logit"))
bmod <- betareg::betareg(ind~trt, data = condat)
summary(brrand)
summary(bmod)
# Simulate from the model
# library(ggplot2)
plotdata <- condat
simn = 50
preddat <- expand.grid(treat = rep(c("CONTROL", "PREDATOR"),simn),
block = c("g1","g2","g3","g4","g5","g6"))
preddat$predicted <- stack(simulate(bmod, nsim = simn))[,1]
ggplot(plotdata, aes(y = ind, x = trt))+
geom_jitter(data = preddat, aes(y = predicted, x = treat),
size = 2, colour = "blue")+
geom_jitter(size = 2,colour = "orange")
summary(lmeSimp)
summary(lmSimp)
sigma(lmSimp)
summary(trmod)
# This add colors manually
cond1 <- clippedpd$trt %in% c("WEEVIL25","WEEVIL125")
cond2 <- clippedpd$type %in% "Connectance"
clippedpd[cond1 & cond2,]$colors <- sigcol
# Grradient significance
# gradvec <- c(1,2,3,4,5)
# names(gradvec) <- treats_to_plot
# condat$graddat <- gradvec[as.character(condat$trt)]
#
# brrandgrad <- glmmTMB(ind ~ graddat + (1|block), data = condat,
#                   family= beta_family(link = "logit"))
# summary(brrandgrad)
# library(mgcv)
# gam1 <- gam(ind~s(graddat, k=5), data=condat)
# summary(gam1)
# plot(gam1,pages=1,residuals=TRUE)  ## show partial residuals
# plot(gam1,pages=1,seWithMean=TRUE) ## `with intercept' CIs
# ## run some basic model checks, including checking
# # ## smoothing basis dimensions...
# gam.check(gam1)
# summary(lm(ind ~ poly(graddat, 3), data=condat))
# # linear fits better...
# 2.3 Generality ----
# Use of the truncated normal distribution
gendat <- desStatMod(clippedpd, "Generality")
trunc <- summary(truncreg(ind~trt, gendat)) # ns
summary(trunc)
# var.test(ind~trt, data = gendat)
# bartlett.test(ind~trt, data = gendat)
car::leveneTest(ind~trt, data = gendat)
# No better ideas
genlm <- lm(ind~trt, gendat)
genlmer <- lmer(ind~trt+(1|block), gendat) #ns
summary(genlm)
summary(genlmer)
# plot(gendat$ind~gendat$trt)
#
# plotdata <- condat
# simn = 50
# preddat <- expand.grid(treat = rep(c("CONTROL", "PREDATOR"),simn),
#                        block = c("g1","g2","g3","g4","g5","g6"))
# preddat$predicted <- stack(simulate(genlmer, nsim = simn))[,1]
#
# ggplot(plotdata, aes(y = ind, x = trt))+
#   geom_jitter(data = preddat, aes(y = predicted, x = treat),
#               size = 2, colour = "blue")+
#   geom_jitter(size = 2,colour = "orange")
# 2.4 Herbivore species [] ----
# Also tested elsewhere
hsdat <- desStatMod(clippedpd, "Herbivore Species")
# summary(glmer.nb(ind~trt+(1|block), hsdat))
# var.test(log(ind)~trt, data = hsdat)
# bartlett.test(log(ind)~trt, data = hsdat)
car::leveneTest(log(ind)~trt, data = hsdat)
# 2.5 Modularity ----
# Can modularity be modified by plant species number?
moddat <- desStatMod(clippedpd, "Modularity")
# var.test(ind~trt, data = moddat)
# bartlett.test(ind~trt, data = moddat)
car::leveneTest(ind~trt, data = moddat)
# plot(moddat$ind~ moddat$trt)
# summary(betareg::betareg(ind~trt, data=moddat))
plot(ind~trt,moddat)
# relevel treatments
# moddat$trt <- factor(moddat$trt,
#                      levels = c("PREDATOR",
#                                 "WEEVIL125",
#                                 "CONTROL",
#                                 "WEEVIL25"))
# summary(nlme::lme(logit(ind)~trt, random = ~1|block, moddat))
br <- glmmTMB(ind ~ trt, data = moddat,
family= beta_family(link = "logit"))
brrand <- glmmTMB(ind ~ trt+(1|block),
data = moddat,
family= beta_family(link = "logit"))
summary(brrand)
summary(br) # random effect is significant
anova(br, brrand, test="Chisq") # differnce is significant
# brtest <- emmeans(br, "trt")
# brrandtest <- emmeans(brrand, "trt")
# pairwise <- cld(brtest, Letter="abcdefghijklm")
# pairwise <- cld(brrandtest, Letter="abcdefghijklm")
# Something is wrong with blocks in this dataset! - SOLVED
# ggplot(moddat, aes(y=ind, x =trt, col=block)) +
#   geom_jitter(width = 0.1, cex = 5)
# gradient not significant for modularity
gradvec <- c(1,2,3,4,5)
names(gradvec) <- treats_to_plot
moddat$graddat <- gradvec[as.character(moddat$trt)]
modgrad <- glmmTMB(ind ~ graddat+sr+(1|block),
data = moddat,
family= beta_family(link = "logit"))
modgrad <- glmmTMB(ind ~ graddat+(1|block),
data = moddat,
family= beta_family(link = "logit"))
# But the gradienty is significant when we include cole001
summary(modgrad)
# 2.6 IP species [calculated elsewhere] ----
ipdat <- desStatMod(clippedpd, "IP Species")
# summary(glmer.nb(ind~trt+(1|block), ipdat))
# var.test(log(ind)~trt, data = ipdat)
# bartlett.test(log(ind)~trt, data = ipdat)
car::leveneTest(ind~trt, data = ipdat)
# 2.7 Nestedness ----
nsdat <- desStatMod(clippedpd, "Nestedness")
# nslmer <- lmer(ind~trt+(1|block), nsdat)
# var.test(ind~trt, data = nsdat)
# bartlett.test(ind~trt, data = nsdat)
car::leveneTest(ind~trt, data = nsdat)
nslme <- nlme::lme(ind~trt, random=~1|block, nsdat)
nslm <- nlme::gls(ind~trt, nsdat)
anova(nslm, nslme)
summary(nslme)
summary(nslm)
plot(nslme)
# Not significant
# 2.8 Specialization PDI ----
pddat <- desStatMod(clippedpd, "Specialization PDI")
# pdlmer1 <- lmer(ind~trt+(1|block), pddat)
# pdlme <- nlme::lme(ind~trt, random=~1|block, pddat)
pdbeta <- glmmTMB(ind ~ trt+(1|block),
data = pddat,
family= beta_family(link = "logit"))
# var.test(ind~trt, data = pddat)
# bartlett.test(ind~trt, data = pddat)
# car::leveneTest(ind~trt, data = pddat)
# pdlmer2 <- lmer(logit(ind)~trt+(1|block), pddat)
# summary(pdlmer1)
summary(pdbeta)
# summary(pdlmer2)
# See if the gradient is significant
# gradvec <- c(1,2,3,4,5)
# names(gradvec) <- treats_to_plot
# pddat$graddat <- gradvec[as.character(pddat$trt)]
# pdlme <- nlme::lme(ind~graddat, random=~1|block, pddat)
# summary(pdlme)
# gradient seems to result in a decrease
# Gam
# gam1 <- gam(ind~s(graddat, k=3), data=pddat)
# summary(gam1)
# plot(gam1,pages=1,residuals=TRUE)  ## show partial residuals
# plot(gam1,pages=1,seWithMean=TRUE) ## `with intercept' CIs
# ## run some basic model checks, including checking
# ## smoothing basis dimensions...
# gam.check(gam1)
# 2.9 Vulnerability ----
vuldat <- desStatMod(clippedpd, "Vulnerability")
trmod <- (truncreg(ind~trt, vuldat))
vullmer <- nlme::lme(ind~trt, random = ~1|block, vuldat)
summary(vullmer)
summary(trmod)
# plotdata <- vuldat
# simn = 50
# preddat <- expand.grid(treat = rep(c("CONTROL", "PREDATOR"),simn),
#                        block = c("g1","g2","g3","g4","g5","g6"))
# preddat$predicted <- stack(simulate(vullmer, nsim = simn))[,1]
#
# ggplot(plotdata, aes(y = ind, x = trt))+
#   geom_jitter(data = preddat, aes(y = predicted, x = treat),
#               size = 2, colour = "blue")+
#   geom_jitter(size = 2,colour = "orange")
car::leveneTest(ind~trt, data = vuldat)
# AIC(trmod, vullmer)
# sigind <- c("Vulnerability",
#             "Specialization PDI",
#             "Herbivore Species",
#             "IP Species",
#             "Modularity")
#
# clippedpd <- clippedpd[clippedpd$type %in% sigind, ]
# 3. Clipped plot ----
# plotdat_filtered <- plotdatrep(,
#                     each=length(as.character(genvuldf$plot)))
clippedpd$trt <- factor(clippedpd$trt,
levels = treats_to_plot,
labels = c("I",
"C",
"P",
"W25",
"W125"))
indices_to_plot <- c("Generality", "Vulnerability", "Specialization PDI", "Connectance",
"Modularity", "Nestedness")
clippedpd_itp <- clippedpd[clippedpd$type %in% indices_to_plot, ]
# Connectance
# p <- ggplot(clippedpd_itp, aes(x = trt, y = ind))
# p + stat_summary(fun=mean_cl_boot,
#                  geom="pointrange", width=0.1,
#                  color = colors, lwd=1)+
#   stat_summary(fun=mean,
#                geom="point",
#                color=colors, cex = 2)
#   # geom_jitter(width = 0.1, col = rgb(128,128,128, alpha = 100, maxColorValue = 255)) +
#   # theme_bw() +
#   # theme(axis.text.x=element_text(angle=0, size=5, hjust=0.5))+
#   # facet_wrap(~type, scales="free")+
#   # ylab("")+xlab("")
# Assign colors for significant and non-significant differences
sigcol <- rgb(255,0,0,150,maxColorValue = 255)
nsigcol <- rgb(10,10,10,50,maxColorValue = 255)
contcol <- rgb(10,10,10,150,maxColorValue = 255)
msigncol <- rgb(255,142,0, 150, maxColorValue = 255)
sigcol <- "red"
nsigcol <- "grey50"
contcol <- "black"
msigncol <- "gold"
sigcolors <- rep(nsigcol, length(treats_to_plot)*length(indices_to_plot))
# Control plots
sigcolors[2] <- contcol
sigcolors[7] <- contcol
sigcolors[12] <- contcol
sigcolors[17] <- contcol
sigcolors[22] <- contcol
sigcolors[27] <- contcol
# Marginally significant
sigcolors[28] <- msigncol
sigcolors[30] <- msigncol
# Significant
sigcolors[c(4,5)] <- sigcol
# Fix the labels
sigcolors <- sigcolors[!is.na(sigcolors)]
# Sigcolors not included
# ggplot(clippedpd_itp,
#        aes(x = trt,
#            y = ind))+
#   geom_jitter(width = 0.1,
#               col = rgb(150,150,150,80,
#                         maxColorValue = 255))+
#   geom_line(aes(group=block),
#             lty = 2,
#             col = rgb(150,150,150,80,
#                       maxColorValue = 255)) +
#   facet_wrap(~type,
#              scales = "free") +
#   stat_summary(fun.data=mean_cl_boot,
#                geom="pointrange",
#                lwd=0.8) +
#   stat_summary(fun=mean,
#                geom="point",
#                cex = 2)+
#   xlab("")+ylab("")
#
# sigcolors
colvals <-  c("black", "black",
"black", "black",
"black", "red",
"black", "black",
"black", "black",
"black", "gold")
pDplot <- ggplot(clippedpd_itp,
aes(x = trt,
y = ind))+
geom_jitter(width = 0.05,
col = rgb(0,0,0,0.3),
size = 3)+
geom_line(aes(group = block), lty = 2,
col = rgb(0,0,0,0.1))+
facet_wrap(~type, ncol=3, scales = "free") +
stat_summary(fun.data=mean_cl_boot,
geom="pointrange", col = colvals,
lwd=1) +
theme_bw() +
theme(strip.text = element_text(face = "bold", size = 10))+
scale_x_discrete(labels = c("C", "Ex"))+
scale_y_continuous(breaks = scales::pretty_breaks(n = 6))+
xlab("")+ylab("")
# pDplot
tiff(filename='ms1/draft_4/figures/fig4.tif',
height=5600,
width=5200,
units='px',
res=800,compression='lzw')
# svg("ms1/draft_4/figures/fig4.svg", width = 6, height= 4)
pDplot
dev.off()
